## 初见

《趣谈网络协议》第17讲

https://time.geekbang.org/column/article/9707

### P2P是什么

想要下载一个文件的时候，你只要得到那些已经存在了文件的 peer，并和这些 peer 之间，建立点对点的连接，而不需要到中心服务器上，就可以就近下载文件。

一旦下载了文件，你也就成为 peer 中的一员，你旁边的那些机器，也可能会选择从你这里下载文件，所以当你使用 P2P 软件的时候，例如 BitTorrent，往往能够看到，既有下载流量，也有上传的流量，也即你自己也加入了这个 P2P 的网络，自己从别人那里下载，同时也提供给其他人下载。

可以想象，这种方式，参与的人越多，下载速度越快，一切完美。

### 种子.torrent文件

原始的p2p有一个问题，当你想下载一个文件的时候，怎么知道哪些 peer 有这个文件呢？这就用到种子啦，也即咱们比较熟悉的.torrent 文件。

.torrent 文件由两部分组成，分别是：**文件信息**和**announce（tracker URL）**。

文件信息里面有这些内容：

- info 区：

  这里指定的是该种子有几个文件、文件有多长、目录结构，以及目录和文件的名字。

- Name 字段：

  指定顶层目录名字。

- 每个段的大小：

  BitTorrent（简称 BT）协议把一个文件分成很多个小段，然后分段下载。

- 段哈希值：

  将整个种子中，每个段的 SHA-1 哈希值拼在一起。

下载时，BT 客户端首先解析.torrent 文件，得到 tracker 地址，然后连接 **tracker 服务器**。

tracker 服务器回应下载者的请求，将其他下载者（包括发布者）的 IP 提供给下载者。

下载者再连接其他下载者，根据.torrent 文件，两者分别向对方告知自己已经有的块，然后交换对方没有的数据。

此时不需要其他服务器参与，并分散了单个线路上的数据流量，因此减轻了服务器的负担。

下载者每得到一个块，需要算出下载块的 Hash 验证码，并与.torrent 文件中的对比。如果一样，则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容的准确性问题。

从这个过程也可以看出，这种方式特别依赖 tracker。tracker 需要收集下载者信息的服务器，并将此信息提供给其他下载者，使下载者们相互连接起来，传输数据。虽然下载的过程是非中心化的，但是加入这个 P2P 网络的时候，都需要借助 tracker 中心服务器，**这个服务器是用来登记有哪些用户在请求哪些资源**。所以，**这种工作方式有一个弊端，一旦 tracker 服务器出现故障或者线路遭到屏蔽，BT 工具就无法正常工作了**。

### 去中心化网络（DHT）

那能不能彻底非中心化呢？

于是，后来就有了一种叫作 DHT（Distributed Hash Table）的去中心化网络。

每个加入这个 DHT 网络的人，都要负责存储这个网络里的资源信息和其他成员的联系信息，相当于所有人一起构成了一个庞大的分布式存储数据库。

有一种著名的 DHT 协议，叫 Kademlia 协议。这个和区块链的概念一样，很抽象，我来详细讲一下这个协议。

任何一个 BitTorrent 启动之后，它都有两个角色：

- **peer角色**：

  监听一个 TCP 端口，用来上传和下载文件，这个角色表明，我这里有某个文件。

- **DHT node角色**：

  监听一个 UDP 的端口，通过这个角色，这个节点加入了一个 DHT 的网络。

在 DHT 网络里面，每一个 DHT node 都有一个 ID。这个 ID 是一个很长的串。每个 DHT node 都有责任掌握一些知识，**也就是文件索引，也即它应该知道某些文件是保存在哪些节点上**。它只需要有这些知识就可以了，**而它自己本身不一定就是保存这个文件的节点**。

#### 哈希值

当然，每个 DHT node 不会有全局的知识，也即不知道所有的文件保存在哪里，它只需要知道一部分。

那应该知道哪一部分呢？这就需要用哈希算法计算出来。

每个文件可以计算出一个哈希值，而 DHT node 的 ID 是和哈希值相同长度的串。

DHT 算法是这样规定的：如果一个文件计算出一个哈希值，则ID和这个哈希值一样的那个 DHT node，就有责任知道从哪里下载这个文件，即便它自己没保存这个文件。

当然不一定这么巧，总能找到和哈希值一模一样的，有可能一模一样的 DHT node 也下线了，所以 DHT 算法还规定：除了一模一样的那个 DHT node 应该知道，ID 和这个哈希值非常接近的 N 个 DHT node 也应该知道。

什么叫和哈希值接近呢？例如只修改了最后一位，就很接近；修改了倒数 2 位，也不远；修改了倒数 3 位，也可以接受。总之，凑齐了规定的 N 这个数就行。

!\[Image text](https://github.com/zwGithubStation/zwKade/blob/main/pic/80ecacb45587d201cbb9a08c31476d27.webp)

刚才那个图里，文件 1 通过哈希运算，得到匹配 ID 的 DHT node 为 node C，当然还会有其他的，我这里没有画出来。所以，node C 有责任知道文件 1 的存放地址，虽然 node C 本身没有存放文件 1。同理，文件 2 通过哈希运算，得到匹配 ID 的 DHT node 为 node E，但是 node D 和 E 的 ID 值很近，所以 node D 也知道。当然，文件 2 本身没有必要一定在 node D 和 E 里，但是碰巧这里就在 E 那有一份。接下来一个新的节点 node new 上线了。如果想下载文件 1，它首先要加入 DHT 网络，如何加入呢？在这种模式下，种子.torrent 文件里面就不再是 tracker 的地址了，而是一个 list 的 node 的地址，而所有这些 node 都是已经在 DHT 网络里面的。当然随着时间的推移，很可能有退出的，有下线的，但是我们假设，不会所有的都联系不上，总有一个能联系上。node new 只要在种子里面找到一个 DHT node，就加入了网络。node new 会计算文件 1 的哈希值，并根据这个哈希值了解到，和这个哈希值匹配，或者很接近的 node 上知道如何下载这个文件，例如计算出来的哈希值就是 node C。但是 node new 不知道怎么联系上 node C，因为种子里面的 node 列表里面很可能没有 node C
